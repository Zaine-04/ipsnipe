#!/usr/bin/env python3
"""
Report generation functionality for ipsnipe
Creates summary reports and analysis from scan results
"""

import datetime
from pathlib import Path
from typing import Dict, List
from ..ui.colors import Colors


class ReportGenerator:
    """Generate summary reports and analysis"""
    
    def __init__(self, output_dir: str):
        self.output_dir = output_dir
    
    def generate_summary_report(self, target_ip: str, results: Dict, open_ports: List[int], web_ports: List[int]):
        """Generate comprehensive summary report"""
        report_file = Path(self.output_dir) / "SUMMARY_REPORT.md"
        
        with open(report_file, 'w') as f:
            self._write_header(f, target_ip)
            self._write_executive_summary(f, results, open_ports, web_ports)
            self._write_detailed_findings(f, results)
            self._write_recommendations(f, results, open_ports, web_ports)
            self._write_scan_details(f, results)
            self._write_footer(f)
        
        print(f"{Colors.GREEN}📊 Summary report generated: {report_file}{Colors.END}")
        print(f"{Colors.CYAN}💡 Open the report for detailed analysis and recommendations{Colors.END}")
    
    def _write_header(self, f, target_ip: str):
        """Write report header"""
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        f.write(f"""# ipsnipe Reconnaissance Report

**Target IP:** {target_ip}  
**Scan Date:** {timestamp}  
**Generated by:** ipsnipe v1.0.5  

---

## 🎯 Executive Summary

""")
    
    def _write_executive_summary(self, f, results: Dict, open_ports: List[int], web_ports: List[int]):
        """Write executive summary"""
        completed_scans = [scan for scan, result in results.items() if result.get('status') == 'success']
        failed_scans = [scan for scan, result in results.items() if result.get('status') == 'failed']
        skipped_scans = [scan for scan, result in results.items() if result.get('status') == 'skipped']
        
        f.write(f"""### 📊 Scan Overview

- **Total Scans Executed:** {len(results)}
- **Successful Scans:** {len(completed_scans)}
- **Failed Scans:** {len(failed_scans)}
- **Skipped Scans:** {len(skipped_scans)}

### 🔍 Key Findings

- **Open Ports Discovered:** {len(open_ports)}
- **Web Services Detected:** {len(web_ports)}
- **Potential Attack Surface:** {'High' if len(open_ports) > 10 else 'Medium' if len(open_ports) > 5 else 'Low'}

""")
        
        if open_ports:
            f.write(f"**Open Ports:** {', '.join(map(str, sorted(open_ports)))}\n\n")
        
        if web_ports:
            f.write(f"**Web Service Ports:** {', '.join(map(str, sorted(web_ports)))}\n\n")
    
    def _write_detailed_findings(self, f, results: Dict):
        """Write detailed findings section"""
        f.write("""---

## 🔬 Detailed Findings

""")
        
        # Network Reconnaissance
        nmap_scans = ['nmap_quick', 'nmap_full', 'nmap_udp']
        if any(scan in results for scan in nmap_scans):
            f.write("### 🌐 Network Reconnaissance\n\n")
            
            for scan in nmap_scans:
                if scan in results:
                    self._write_scan_summary(f, scan, results[scan])
        
        # Web Application Testing
        web_scans = ['gobuster_common', 'gobuster_big', 'feroxbuster', 'ffuf', 'nikto', 'whatweb']
        if any(scan in results for scan in web_scans):
            f.write("### 🌐 Web Application Testing\n\n")
            
            for scan in web_scans:
                if scan in results:
                    self._write_scan_summary(f, scan, results[scan])
        
        # Information Gathering
        info_scans = ['theharvester', 'dnsrecon']
        if any(scan in results for scan in info_scans):
            f.write("### 📧 Information Gathering\n\n")
            
            for scan in info_scans:
                if scan in results:
                    self._write_scan_summary(f, scan, results[scan])
    
    def _write_scan_summary(self, f, scan_name: str, result: Dict):
        """Write individual scan summary"""
        status = result.get('status', 'unknown')
        status_emoji = {
            'success': '✅',
            'failed': '❌',
            'skipped': '⏭️',
            'timeout': '⏰',
            'not_found': '🚫'
        }.get(status, '❓')
        
        scan_title = scan_name.replace('_', ' ').title()
        f.write(f"#### {status_emoji} {scan_title}\n\n")
        
        if status == 'success':
            execution_time = result.get('execution_time', 0)
            file_size = result.get('file_size', 0)
            f.write(f"- **Status:** Completed successfully\n")
            f.write(f"- **Execution Time:** {execution_time:.1f} seconds\n")
            f.write(f"- **Output Size:** {file_size} bytes\n")
            f.write(f"- **Output File:** `{Path(result.get('output_file', '')).name}`\n\n")
            
            # Add scan-specific insights
            self._add_scan_insights(f, scan_name, result)
            
        elif status == 'skipped':
            reason = result.get('reason', 'Unknown reason')
            f.write(f"- **Status:** Skipped\n")
            f.write(f"- **Reason:** {reason}\n")
            if 'recommendation' in result:
                f.write(f"- **Recommendation:** {result['recommendation']}\n")
            f.write("\n")
            
        elif status == 'failed':
            f.write(f"- **Status:** Failed\n")
            f.write(f"- **Return Code:** {result.get('return_code', 'N/A')}\n")
            f.write(f"- **Output File:** `{Path(result.get('output_file', '')).name}` (check for error details)\n\n")
            
        elif status == 'timeout':
            timeout_duration = result.get('timeout_duration', 0)
            f.write(f"- **Status:** Timed out after {timeout_duration} seconds\n")
            f.write(f"- **Recommendation:** Consider increasing timeout or reducing scan scope\n\n")
    
    def _add_scan_insights(self, f, scan_name: str, result: Dict):
        """Add scan-specific insights"""
        insights = {
            'nmap_quick': "Quick port scan for initial reconnaissance. Check output for open ports and running services.",
            'nmap_full': "Comprehensive port scan with service detection. Review for detailed service versions and potential vulnerabilities.",
            'nmap_udp': "UDP port scan for services not detected by TCP scans. Check for DNS, SNMP, DHCP services.",
            'gobuster_common': "Directory enumeration with common wordlist. Review for hidden directories and files.",
            'gobuster_big': "Extensive directory enumeration. May reveal additional attack surfaces.",
            'feroxbuster': "Recursive content discovery. Check for nested directories and files.",
            'ffuf': "Fast fuzzing results. Review status codes and response sizes for interesting findings.",
            'nikto': "Web vulnerability scan. **CRITICAL:** Review all findings for security issues.",
            'whatweb': "Technology fingerprinting. Useful for understanding the web stack and potential vulnerabilities.",
            'theharvester': "Email and subdomain enumeration. May reveal additional targets.",
            'dnsrecon': "DNS reconnaissance. Check for additional hosts and network information."
        }
        
        insight = insights.get(scan_name, "Review the output file for detailed results.")
        f.write(f"- **Analysis:** {insight}\n\n")
    
    def _write_recommendations(self, f, results: Dict, open_ports: List[int], web_ports: List[int]):
        """Write recommendations section"""
        f.write("""---

## 🛡️ Security Recommendations

### Immediate Actions

""")
        
        # Port-based recommendations
        if open_ports:
            f.write("#### Network Security\n")
            
            risky_ports = [21, 22, 23, 53, 135, 139, 445, 1433, 3389, 5432]
            found_risky = [port for port in open_ports if port in risky_ports]
            
            if found_risky:
                f.write(f"- **High Priority:** Review services on ports {', '.join(map(str, found_risky))} - these commonly have security implications\n")
            
            if len(open_ports) > 10:
                f.write("- **Medium Priority:** Large number of open ports detected - consider principle of least privilege\n")
            
            f.write("- Ensure all open services are necessary and properly configured\n")
            f.write("- Implement proper firewall rules to restrict access\n")
            f.write("- Keep all services updated with latest security patches\n\n")
        
        # Web-specific recommendations
        if web_ports:
            f.write("#### Web Application Security\n")
            f.write("- Review all discovered directories and files for sensitive information\n")
            f.write("- Ensure proper access controls are in place\n")
            f.write("- Check for default credentials and configurations\n")
            
            if 'nikto' in results and results['nikto'].get('status') == 'success':
                f.write("- **CRITICAL:** Review Nikto scan results for security vulnerabilities\n")
            
            f.write("- Implement HTTPS for all web services\n")
            f.write("- Consider implementing Web Application Firewall (WAF)\n\n")
        
        # General recommendations
        f.write("""#### General Security Practices

- Implement network segmentation where possible
- Regular security assessments and penetration testing
- Monitor network traffic for unusual activities
- Implement intrusion detection/prevention systems
- Regular backup and disaster recovery testing
- Security awareness training for users

""")
    
    def _write_scan_details(self, f, results: Dict):
        """Write technical scan details"""
        f.write("""---

## 📋 Technical Details

### Scan Execution Summary

| Scan Module | Status | Execution Time | Output Size | Notes |
|-------------|--------|----------------|-------------|-------|
""")
        
        for scan_name, result in results.items():
            status = result.get('status', 'unknown')
            exec_time = result.get('execution_time', 0)
            file_size = result.get('file_size', 0)
            
            # Format execution time
            time_str = f"{exec_time:.1f}s" if exec_time > 0 else "N/A"
            
            # Format file size
            if file_size > 0:
                if file_size < 1024:
                    size_str = f"{file_size}B"
                elif file_size < 1024*1024:
                    size_str = f"{file_size/1024:.1f}KB"
                else:
                    size_str = f"{file_size/(1024*1024):.1f}MB"
            else:
                size_str = "N/A"
            
            # Notes
            notes = ""
            if status == 'skipped':
                notes = result.get('reason', 'Skipped')
            elif status == 'failed':
                notes = f"Exit code: {result.get('return_code', 'N/A')}"
            elif status == 'timeout':
                notes = "Timed out"
            
            f.write(f"| {scan_name.replace('_', ' ').title()} | {status.title()} | {time_str} | {size_str} | {notes} |\n")
        
        f.write("\n")
    
    def _write_footer(self, f):
        """Write report footer"""
        f.write("""---

## ℹ️ About This Report

This report was generated automatically by **ipsnipe v1.0.5**, an advanced reconnaissance framework.

### Important Notes

- This scan was performed for authorized security testing purposes only
- All findings should be properly validated before taking action
- Regular security assessments are recommended
- Consider engaging security professionals for comprehensive testing

### Next Steps

1. Review all scan output files for detailed information
2. Validate and prioritize findings based on business impact
3. Develop remediation plans for identified issues
4. Schedule follow-up scans to verify fixes

---

*Report generated on {timestamp}*

**Disclaimer:** This tool should only be used on systems you own or have explicit permission to test.
""".format(timestamp=datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))) 