#!/usr/bin/env python3
"""
Report generation functionality for ipsnipe
Creates summary reports and analysis from scan results
"""

import datetime
import os
import re
from pathlib import Path
from typing import Dict, List, Optional
from ..ui.colors import Colors


class ReportGenerator:
    """Generate summary reports and analysis"""
    
    def __init__(self, output_dir: str):
        self.output_dir = output_dir
    
    def generate_summary_report(self, target_ip: str, results: Dict, open_ports: List[int], 
                               web_ports: List[int], domains: List[str] = None):
        """Generate comprehensive summary report"""
        report_file = Path(self.output_dir) / "SUMMARY_REPORT.md"
        findings_file = Path(self.output_dir) / "KEY_FINDINGS.md"
        
        # Generate main report
        with open(report_file, 'w') as f:
            self._write_header(f, target_ip, domains)
            self._write_executive_summary(f, results, open_ports, web_ports, domains)
            self._write_detailed_findings(f, results)
            self._write_recommendations(f, results, open_ports, web_ports)
            self._write_scan_details(f, results)
            self._write_footer(f)
        
        # Generate key findings report
        key_findings = self._extract_key_findings(results)
        self._generate_key_findings_report(findings_file, target_ip, key_findings, domains)
        
        print(f"{Colors.GREEN}üìä Summary report generated: {report_file}{Colors.END}")
        print(f"{Colors.GREEN}üîç Key findings report: {findings_file}{Colors.END}")
        print(f"{Colors.CYAN}üí° Open the reports for detailed analysis and recommendations{Colors.END}")
    
    def _write_header(self, f, target_ip: str, domains: List[str] = None):
        """Write report header"""
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        f.write(f"""# ipsnipe Reconnaissance Report

**Target IP:** {target_ip}  
""")
        if domains:
            f.write(f"**Discovered Domains:** {', '.join(domains)}  \n")
        
        f.write(f"""**Scan Date:** {timestamp}  
**Generated by:** ipsnipe v1.0.6  

---

## üéØ Executive Summary

""")
    
    def _write_executive_summary(self, f, results: Dict, open_ports: List[int], 
                                web_ports: List[int], domains: List[str] = None):
        """Write executive summary"""
        completed_scans = [scan for scan, result in results.items() if result.get('status') == 'success']
        failed_scans = [scan for scan, result in results.items() if result.get('status') == 'failed']
        skipped_scans = [scan for scan, result in results.items() if result.get('status') == 'skipped']
        
        f.write(f"""### üìä Scan Overview

- **Total Scans Executed:** {len(results)}
- **Successful Scans:** {len(completed_scans)}
- **Failed Scans:** {len(failed_scans)}
- **Skipped Scans:** {len(skipped_scans)}

### üîç Key Findings

- **Open Ports Discovered:** {len(open_ports)}
- **Web Services Detected:** {len(web_ports)}
""")
        
        if domains:
            f.write(f"- **Domain Names Found:** {len(domains)}\n")
        
        attack_surface = 'High' if len(open_ports) > 10 else 'Medium' if len(open_ports) > 5 else 'Low'
        f.write(f"- **Potential Attack Surface:** {attack_surface}\n\n")
        
        if open_ports:
            f.write(f"**Open Ports:** {', '.join(map(str, sorted(open_ports)))}\n\n")
        
        if web_ports:
            f.write(f"**Web Service Ports:** {', '.join(map(str, sorted(web_ports)))}\n\n")
        
        if domains:
            f.write(f"**Domain Names:**\n")
            for domain in domains:
                f.write(f"- {domain}\n")
            f.write("\n")
    
    def _write_detailed_findings(self, f, results: Dict):
        """Write detailed findings section"""
        f.write("""---

## üî¨ Detailed Findings

""")
        
        # Network Reconnaissance
        nmap_scans = ['nmap_quick', 'nmap_full', 'nmap_udp']
        if any(scan in results for scan in nmap_scans):
            f.write("### üåê Network Reconnaissance\n\n")
            
            for scan in nmap_scans:
                if scan in results:
                    self._write_scan_summary(f, scan, results[scan])
        
        # Web Application Testing
        web_scans = ['gobuster_common', 'gobuster_big', 'feroxbuster', 'ffuf', 'nikto', 'whatweb']
        if any(scan in results for scan in web_scans):
            f.write("### üåê Web Application Testing\n\n")
            
            for scan in web_scans:
                if scan in results:
                    self._write_scan_summary(f, scan, results[scan])
        
        # Information Gathering
        info_scans = ['theharvester', 'dnsrecon']
        if any(scan in results for scan in info_scans):
            f.write("### üìß Information Gathering\n\n")
            
            for scan in info_scans:
                if scan in results:
                    self._write_scan_summary(f, scan, results[scan])
    
    def _write_scan_summary(self, f, scan_name: str, result: Dict):
        """Write individual scan summary"""
        status = result.get('status', 'unknown')
        status_emoji = {
            'success': '‚úÖ',
            'failed': '‚ùå',
            'skipped': '‚è≠Ô∏è',
            'timeout': '‚è∞',
            'not_found': 'üö´'
        }.get(status, '‚ùì')
        
        scan_title = scan_name.replace('_', ' ').title()
        f.write(f"#### {status_emoji} {scan_title}\n\n")
        
        if status == 'success':
            execution_time = result.get('execution_time', 0)
            file_size = result.get('file_size', 0)
            f.write(f"- **Status:** Completed successfully\n")
            f.write(f"- **Execution Time:** {execution_time:.1f} seconds\n")
            f.write(f"- **Output Size:** {file_size} bytes\n")
            f.write(f"- **Output File:** `{Path(result.get('output_file', '')).name}`\n\n")
            
            # Add scan-specific insights
            self._add_scan_insights(f, scan_name, result)
            
        elif status == 'skipped':
            reason = result.get('reason', 'Unknown reason')
            f.write(f"- **Status:** Skipped\n")
            f.write(f"- **Reason:** {reason}\n")
            if 'recommendation' in result:
                f.write(f"- **Recommendation:** {result['recommendation']}\n")
            f.write("\n")
            
        elif status == 'failed':
            f.write(f"- **Status:** Failed\n")
            f.write(f"- **Return Code:** {result.get('return_code', 'N/A')}\n")
            f.write(f"- **Output File:** `{Path(result.get('output_file', '')).name}` (check for error details)\n\n")
            
        elif status == 'timeout':
            timeout_duration = result.get('timeout_duration', 0)
            f.write(f"- **Status:** Timed out after {timeout_duration} seconds\n")
            f.write(f"- **Recommendation:** Consider increasing timeout or reducing scan scope\n\n")
    
    def _add_scan_insights(self, f, scan_name: str, result: Dict):
        """Add scan-specific insights"""
        insights = {
            'nmap_quick': "Quick port scan for initial reconnaissance. Check output for open ports and running services.",
            'nmap_full': "Comprehensive port scan with service detection. Review for detailed service versions and potential vulnerabilities.",
            'nmap_udp': "UDP port scan for services not detected by TCP scans. Check for DNS, SNMP, DHCP services.",
            'gobuster_common': "Directory enumeration with common wordlist. Review for hidden directories and files.",
            'gobuster_big': "Extensive directory enumeration. May reveal additional attack surfaces.",
            'feroxbuster': "Recursive content discovery. Check for nested directories and files.",
            'ffuf': "Fast fuzzing results. Review status codes and response sizes for interesting findings.",
            'nikto': "Web vulnerability scan. **CRITICAL:** Review all findings for security issues.",
            'whatweb': "Technology fingerprinting. Useful for understanding the web stack and potential vulnerabilities.",
            'theharvester': "Email and subdomain enumeration. May reveal additional targets.",
            'dnsrecon': "DNS reconnaissance. Check for additional hosts and network information."
        }
        
        insight = insights.get(scan_name, "Review the output file for detailed results.")
        f.write(f"- **Analysis:** {insight}\n\n")
    
    def _write_recommendations(self, f, results: Dict, open_ports: List[int], web_ports: List[int]):
        """Write recommendations section"""
        f.write("""---

## üõ°Ô∏è Security Recommendations

### Immediate Actions

""")
        
        # Port-based recommendations
        if open_ports:
            f.write("#### Network Security\n")
            
            risky_ports = [21, 22, 23, 53, 135, 139, 445, 1433, 3389, 5432]
            found_risky = [port for port in open_ports if port in risky_ports]
            
            if found_risky:
                f.write(f"- **High Priority:** Review services on ports {', '.join(map(str, found_risky))} - these commonly have security implications\n")
            
            if len(open_ports) > 10:
                f.write("- **Medium Priority:** Large number of open ports detected - consider principle of least privilege\n")
            
            f.write("- Ensure all open services are necessary and properly configured\n")
            f.write("- Implement proper firewall rules to restrict access\n")
            f.write("- Keep all services updated with latest security patches\n\n")
        
        # Web-specific recommendations
        if web_ports:
            f.write("#### Web Application Security\n")
            f.write("- Review all discovered directories and files for sensitive information\n")
            f.write("- Ensure proper access controls are in place\n")
            f.write("- Check for default credentials and configurations\n")
            
            if 'nikto' in results and results['nikto'].get('status') == 'success':
                f.write("- **CRITICAL:** Review Nikto scan results for security vulnerabilities\n")
            
            f.write("- Implement HTTPS for all web services\n")
            f.write("- Consider implementing Web Application Firewall (WAF)\n\n")
        
        # General recommendations
        f.write("""#### General Security Practices

- Implement network segmentation where possible
- Regular security assessments and penetration testing
- Monitor network traffic for unusual activities
- Implement intrusion detection/prevention systems
- Regular backup and disaster recovery testing
- Security awareness training for users

""")
    
    def _write_scan_details(self, f, results: Dict):
        """Write technical scan details"""
        f.write("""---

## üìã Technical Details

### Scan Execution Summary

| Scan Module | Status | Execution Time | Output Size | Notes |
|-------------|--------|----------------|-------------|-------|
""")
        
        for scan_name, result in results.items():
            status = result.get('status', 'unknown')
            exec_time = result.get('execution_time', 0)
            file_size = result.get('file_size', 0)
            
            # Format execution time
            time_str = f"{exec_time:.1f}s" if exec_time > 0 else "N/A"
            
            # Format file size
            if file_size > 0:
                if file_size < 1024:
                    size_str = f"{file_size}B"
                elif file_size < 1024*1024:
                    size_str = f"{file_size/1024:.1f}KB"
                else:
                    size_str = f"{file_size/(1024*1024):.1f}MB"
            else:
                size_str = "N/A"
            
            # Notes
            notes = ""
            if status == 'skipped':
                notes = result.get('reason', 'Skipped')
            elif status == 'failed':
                notes = f"Exit code: {result.get('return_code', 'N/A')}"
            elif status == 'timeout':
                notes = "Timed out"
            
            f.write(f"| {scan_name.replace('_', ' ').title()} | {status.title()} | {time_str} | {size_str} | {notes} |\n")
        
        f.write("\n")
    
    def _write_footer(self, f):
        """Write report footer"""
        f.write("""---

## ‚ÑπÔ∏è About This Report

This report was generated automatically by **ipsnipe v1.0.5**, an advanced reconnaissance framework.

### Important Notes

- This scan was performed for authorized security testing purposes only
- All findings should be properly validated before taking action
- Regular security assessments are recommended
- Consider engaging security professionals for comprehensive testing

### Next Steps

1. Review all scan output files for detailed information
2. Validate and prioritize findings based on business impact
3. Develop remediation plans for identified issues
4. Schedule follow-up scans to verify fixes

---

*Report generated on {timestamp}*

**Disclaimer:** This tool should only be used on systems you own or have explicit permission to test.
""".format(timestamp=datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
    
    def _extract_key_findings(self, results: Dict) -> Dict[str, List[str]]:
        """Extract key findings from all scan results"""
        findings = {
            'open_ports': [],
            'web_directories': [],
            'interesting_files': [],
            'vulnerabilities': [],
            'technologies': [],
            'emails': [],
            'subdomains': [],
            'certificates': [],
            'credentials': []
        }
        
        for scan_name, result in results.items():
            if result.get('status') != 'success':
                continue
                
            output_file = result.get('output_file')
            if not output_file:
                continue
                
            file_path = Path(self.output_dir) / output_file
            if not file_path.exists():
                continue
                
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                # Extract findings based on scan type
                if 'nmap' in scan_name:
                    findings['open_ports'].extend(self._extract_nmap_ports(content))
                    findings['certificates'].extend(self._extract_ssl_certificates(content))
                elif any(x in scan_name for x in ['gobuster', 'ferox', 'ffuf']):
                    dirs, files = self._extract_web_findings(content)
                    findings['web_directories'].extend(dirs)
                    findings['interesting_files'].extend(files)
                elif 'nikto' in scan_name:
                    findings['vulnerabilities'].extend(self._extract_nikto_vulns(content))
                elif 'whatweb' in scan_name:
                    findings['technologies'].extend(self._extract_whatweb_tech(content))
                elif 'theharvester' in scan_name:
                    findings['emails'].extend(self._extract_harvester_emails(content))
                    findings['subdomains'].extend(self._extract_harvester_subdomains(content))
                elif 'dnsrecon' in scan_name:
                    findings['subdomains'].extend(self._extract_dnsrecon_subdomains(content))
                
                # Look for credentials in any output
                findings['credentials'].extend(self._extract_credentials(content))
                
            except Exception as e:
                continue
        
        # Remove duplicates and empty entries
        for key in findings:
            findings[key] = sorted(list(set(filter(None, findings[key]))))
        
        return findings
    
    def _extract_nmap_ports(self, content: str) -> List[str]:
        """Extract open ports from nmap output"""
        ports = []
        lines = content.split('\n')
        
        for line in lines:
            # Look for open ports in various nmap formats
            if '/tcp' in line and 'open' in line:
                match = re.search(r'(\d+)/tcp\s+open\s+([^\s]+)', line)
                if match:
                    port, service = match.groups()
                    ports.append(f"{port}/tcp ({service})")
            elif '/udp' in line and 'open' in line:
                match = re.search(r'(\d+)/udp\s+open\s+([^\s]+)', line)
                if match:
                    port, service = match.groups()
                    ports.append(f"{port}/udp ({service})")
        
        return ports
    
    def _extract_web_findings(self, content: str) -> tuple:
        """Extract directories and interesting files from web enumeration"""
        directories = []
        files = []
        
        lines = content.split('\n')
        interesting_extensions = ['.php', '.asp', '.aspx', '.jsp', '.txt', '.xml', '.config', '.bak', '.sql']
        
        for line in lines:
            # Gobuster format
            if line.startswith('/') and ('200' in line or '301' in line or '302' in line):
                path = line.split()[0]
                if any(path.endswith(ext) for ext in interesting_extensions):
                    files.append(path)
                else:
                    directories.append(path)
            
            # Feroxbuster format
            elif 'Status:' in line and ('200' in line or '301' in line):
                match = re.search(r'https?://[^/]+(/[^\s]+)', line)
                if match:
                    path = match.group(1)
                    if any(path.endswith(ext) for ext in interesting_extensions):
                        files.append(path)
                    else:
                        directories.append(path)
        
        return directories, files
    
    def _extract_nikto_vulns(self, content: str) -> List[str]:
        """Extract vulnerabilities from Nikto output"""
        vulns = []
        lines = content.split('\n')
        
        for line in lines:
            if line.startswith('+') and any(x in line.lower() for x in ['vuln', 'security', 'cve']):
                vulns.append(line.strip())
        
        return vulns
    
    def _extract_whatweb_tech(self, content: str) -> List[str]:
        """Extract technologies from WhatWeb output"""
        technologies = []
        
        # Look for technology patterns
        tech_patterns = [
            r'(\w+)\s+\[([^\]]+)\]',  # WhatWeb format
            r'(\w+)\s+(\d+\.\d+[\.\d]*)',  # Version numbers
        ]
        
        for pattern in tech_patterns:
            matches = re.findall(pattern, content)
            for match in matches:
                if isinstance(match, tuple):
                    tech_name = match[0]
                    version = match[1] if len(match) > 1 else ''
                    technologies.append(f"{tech_name} {version}".strip())
        
        return technologies
    
    def _extract_harvester_emails(self, content: str) -> List[str]:
        """Extract emails from theHarvester output"""
        email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        return re.findall(email_pattern, content)
    
    def _extract_harvester_subdomains(self, content: str) -> List[str]:
        """Extract subdomains from theHarvester output"""
        subdomains = []
        lines = content.split('\n')
        
        for line in lines:
            # Look for subdomain patterns
            if '.' in line and not '@' in line:
                # Simple subdomain detection
                match = re.search(r'([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})', line)
                if match:
                    subdomain = match.group(1)
                    if subdomain.count('.') >= 1:
                        subdomains.append(subdomain)
        
        return subdomains
    
    def _extract_dnsrecon_subdomains(self, content: str) -> List[str]:
        """Extract subdomains from DNSrecon output"""
        subdomains = []
        lines = content.split('\n')
        
        for line in lines:
            if 'A' in line or 'CNAME' in line:
                match = re.search(r'([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})', line)
                if match:
                    subdomains.append(match.group(1))
        
        return subdomains
    
    def _extract_ssl_certificates(self, content: str) -> List[str]:
        """Extract SSL certificate information from nmap output"""
        certs = []
        lines = content.split('\n')
        
        for line in lines:
            if 'subject:' in line.lower() or 'issuer:' in line.lower():
                certs.append(line.strip())
        
        return certs
    
    def _extract_credentials(self, content: str) -> List[str]:
        """Look for potential credentials in any output"""
        credentials = []
        
        # Common credential patterns
        patterns = [
            r'username[:\s=]+([^\s\n]+)',
            r'password[:\s=]+([^\s\n]+)',
            r'user[:\s=]+([^\s\n]+)',
            r'pass[:\s=]+([^\s\n]+)',
            r'login[:\s=]+([^\s\n]+)',
        ]
        
        for pattern in patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            for match in matches:
                if len(match) > 2 and match != 'password' and match != 'username':
                    credentials.append(match)
        
        return credentials
    
    def _generate_key_findings_report(self, file_path: Path, target_ip: str, 
                                    findings: Dict[str, List[str]], domains: List[str] = None):
        """Generate a focused key findings report"""
        with open(file_path, 'w') as f:
            f.write(f"""# üîç Key Findings Report

**Target:** {target_ip}
""")
            if domains:
                f.write(f"**Domains:** {', '.join(domains)}\n")
            
            f.write(f"""**Generated:** {datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

---

## üö® Critical Findings

""")
            
            # Prioritize findings
            if findings['vulnerabilities']:
                f.write("### ‚ö†Ô∏è Security Vulnerabilities\n\n")
                for vuln in findings['vulnerabilities'][:10]:  # Top 10
                    f.write(f"- {vuln}\n")
                f.write("\n")
            
            if findings['credentials']:
                f.write("### üîë Potential Credentials\n\n")
                for cred in findings['credentials'][:5]:  # Top 5
                    f.write(f"- {cred}\n")
                f.write("\n")
            
            if findings['interesting_files']:
                f.write("### üìÑ Interesting Files\n\n")
                for file in findings['interesting_files'][:10]:
                    f.write(f"- {file}\n")
                f.write("\n")
            
            # Network information
            if findings['open_ports']:
                f.write("## üåê Network Information\n\n")
                f.write("### Open Ports\n\n")
                for port in findings['open_ports']:
                    f.write(f"- {port}\n")
                f.write("\n")
            
            # Web information
            if findings['web_directories'] or findings['technologies']:
                f.write("## üåê Web Information\n\n")
                
                if findings['web_directories']:
                    f.write("### Discovered Directories\n\n")
                    for directory in findings['web_directories'][:15]:  # Top 15
                        f.write(f"- {directory}\n")
                    f.write("\n")
                
                if findings['technologies']:
                    f.write("### Technologies Detected\n\n")
                    for tech in findings['technologies']:
                        f.write(f"- {tech}\n")
                    f.write("\n")
            
            # Additional information
            if findings['emails'] or findings['subdomains']:
                f.write("## üìß Additional Information\n\n")
                
                if findings['emails']:
                    f.write("### Email Addresses\n\n")
                    for email in findings['emails']:
                        f.write(f"- {email}\n")
                    f.write("\n")
                
                if findings['subdomains']:
                    f.write("### Subdomains\n\n")
                    for subdomain in findings['subdomains'][:10]:
                        f.write(f"- {subdomain}\n")
                    f.write("\n")
            
            f.write("""---

## üìã Next Steps

1. **Investigate vulnerabilities** - Start with highest priority items
2. **Verify credentials** - Test any discovered credentials safely
3. **Explore directories** - Manually browse interesting paths
4. **Technology research** - Look up CVEs for detected versions
5. **Network mapping** - Document network topology and services

*This is a quick reference. See SUMMARY_REPORT.md for complete details.*
""") 